from typing import Optional
from abc import ABC, abstractmethod

# class State
#   - Holds the current information needed to translate statements into machine instructions
#   - Variables:
#       - var_dict: A dictionary [variable name] --> [memory location]
#       - func_dict: A dictionary [function name] --> [instruction number]
#       - cur_mem_addr: Stores the next memory address that is available for use (such as declaring variables)
#       - cur_instruction: Stores the current instruction number, for use such as jumping to functions

class FuncData:
    def __init__(self, name: str, body_statements: list['Translatable'], ret_instr_addr: Optional[int] = None, start_instr: Optional[int] = None):
        self.name: str = name
        self.body_statements: list['Translatable'] = body_statements
        self.ret_instr_addr: Optional[int] = ret_instr_addr
        self.start_instr: Optional[int] = start_instr

class State:
    def __init__(self, def_vars: dict[str, int] = {}, def_funcs: dict[str, FuncData] = {}):
        self.var_dict: dict[str, int] = def_vars
        self.func_dict: dict[str, FuncData] = def_funcs

        self.cur_mem_addr: int = 1

        self.cur_instruction: int = 1

        self.unclaimed_addrs: set[int] = set() # This will be used to store addresses that have been freed, and so are available, set so we can check if an address is already in it quickly

        self.placeholder_instrs: dict[int, str] = {} # This holds the instruction number -> function name, for each placeholder instruction generated by function calls, so they can later be replaced


    def get_var_addr(self, var_name: str) -> Optional[int]:
        if var_name not in self.var_dict:
            return None

        return self.var_dict[var_name]
    
    def add_var(self, var_name: str, addr: int) -> Optional[int]:
        if var_name in self.var_dict:
            return None

        self.var_dict[var_name] = addr

        return addr
    
    def get_func_data(self, func_name: str) -> Optional[FuncData]:
        if func_name not in self.func_dict:
            return None
        
        return self.func_dict[func_name]
    
    def add_func(self, func_name: str , func_data: FuncData) -> Optional[FuncData]:
        if func_name in self.func_dict:
            return None
        
        self.func_dict[func_name] = func_data

        return func_data
    
    def claim_mem_addr(self) -> int:
        # If there are any formerly used addresses that have been unclaimed, use those first
        if len(self.unclaimed_addrs) > 0:
            return self.unclaimed_addrs.pop()

        # Otherwise, use the next available address
        claimed_addr = self.cur_mem_addr
        self.cur_mem_addr += 1

        return claimed_addr
    
    def unclaim_mem_addr(self, addr: int) -> None:
        # First, we will check if the address has been claimed, if so throw an error since this was probably unintended
        if (addr >= self.cur_mem_addr) or (addr in self.unclaimed_addrs):
            raise ValueError(f'Invalid attempt to unclaim address {addr}, not in use')
        
        self.unclaimed_addrs.add(addr)

class Instruction:
    def __init__(self, name: str, id: int, args: list[int]):
        self.name: str = name
        self.id: int = id
        self.args: list[int] = args

    def __str__(self) -> str:
        ret_str = f'I: {self.id}'
        for i, arg in enumerate(self.args):
            ret_str += f' {i}: {arg}'

        return ret_str

class Translatable (ABC):
    @abstractmethod
    def translate(self, state: State) -> list[Instruction]:
        pass